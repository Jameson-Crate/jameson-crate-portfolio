"use client";

import React, { useEffect } from "react";
import { ArrowLeft } from "lucide-react";
import Link from "next/link";
import { ImageFigure } from "../components/ImageFigure";

const ProjectPage = () => {
  useEffect(() => {
    document.title = "Ray Tracing";
  }, []);

  return (
    <div className="min-h-screen bg-gray-50 text-gray-800 p-8 lg:px-20">
      <Link
        href="/"
        className="flex items-center text-blue-600 hover:text-blue-800 mb-6 group"
      >
        <ArrowLeft
          size={20}
          className="mr-2 transition-transform group-hover:-translate-x-1"
        />
        Back to Portfolio
      </Link>

      <h1 className="text-4xl font-bold mb-8 text-center">
        Ray Tracing
      </h1>

      <div className="flex space-x-4 justify-center mb-8">
        {[
          {
            href: "https://github.com/cal-cs184-student/sp25-hw3-make-my-ray",
            text: "GitHub",
          },
        ].map(({ href, text }) => (
          <a
            href={href}
            key={text}
            className="text-gray-600 hover:text-blue-800"
            title={`Visit ${text}`}
            target="_blank"
            rel="noopener noreferrer"
          >
            <h3>{text}</h3>
          </a>
        ))}
      </div>

      <hr className="mb-8" />

      <section className="mb-8">
        <h2 className="text-2xl font-semibold mb-4">Table of Contents</h2>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
          <div>
            <ul className="list-disc list-inside space-y-1">
              <li>
                <a
                  href="#abstract"
                  className="text-blue-600 hover:underline"
                >
                  Abstract
                </a>
              </li>
              <li>
                <a
                  href="#ray-generation"
                  className="text-blue-600 hover:underline"
                >
                  Ray Generation and Scene Intersection
                </a>
              </li>
              <li>
                <a
                  href="#bvh"
                  className="text-blue-600 hover:underline"
                >
                  Bounding Volume Hierarchy
                </a>
              </li>
              <li>
                <a
                  href="#direct-illumination"
                  className="text-blue-600 hover:underline"
                >
                  Direct Illumination
                </a>
              </li>
              <li>
                <a
                  href="#global-illumination"
                  className="text-blue-600 hover:underline"
                >
                  Global Illumination
                </a>
              </li>
              <li>
                <a
                  href="#adaptive-sampling"
                  className="text-blue-600 hover:underline"
                >
                  Adaptive Sampling
                </a>
              </li>
            </ul>
          </div>
        </div>
        <hr className="mt-8" />
      </section>

      <section id="abstract" className="mb-8">
        <h2 className="text-2xl font-semibold mb-4">Abstract</h2>
        <p className="text-lg">
          In this project, I implemented a ray tracer in C++ and used it to render a few scenes. I first implemented a simple ray generator and intersection test for triangles. I then used this to render the Cornell Box with a few different objects. Next I implemented a BVH to speed up the intersection test. I then implemented direct illumination and global illumination with Russian Roulette. Finally, I implemented adaptive sampling to improve the quality of the images.
        </p>
        <hr className="mt-8" />
      </section>

      <section id="ray-generation" className="mb-8">
        <h2 className="text-2xl font-semibold mb-4">Ray Generation and Scene Intersection</h2>
        <p className="text-lg">
          A ray is generated by interpreting the (x,y) coordinates of each sample in the image plane as points on a virtual &quot;sensor&quot; in the camera&apos;s field of view (fov variables in the code) to map those normalized coordinates into a 3D direction. That direction is then normalized and transformed into the world coordinate system (originating at the camera&apos;s position) with the near and far clipping distances applied into the min_t and max_t fields of the ray. For triangle intersections, we used the Moller–Trumbore algorithm: two edges of the triangle are calculated and then a bunch of cross and dot products to find the position &quot;t&quot; along the ray and the barycentric coordinates of the point on the triangle&apos;s surface using barycentric interpolation. If t is within the ray&apos;s valid range (set by min_t and max_t earlier up) and all barycentric coordinates lie between 0 and 1, the intersection is valid; at which point, the intersection record is updated accordingly (updating isect and the new max_t).
        </p>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-8 mt-8">
          <ImageFigure
            src="/assets/project9/part-1/CBbunny.png"
            alt="Cornell Box with Bunny"
            caption="Cornell Box with Bunny"
            width={400}
            height={400}
          />
          <ImageFigure
            src="/assets/project9/part-1/CBcoil.png"
            alt="Cornell Box with Coil"
            caption="Cornell Box with Coil"
            width={400}
            height={400}
          />
          <ImageFigure
            src="/assets/project9/part-1/CBgems.png"
            alt="Cornell Box with Gems"
            caption="Cornell Box with Gems"
            width={400}
            height={400}
          />
          <ImageFigure
            src="/assets/project9/part-1/CBspheres.png"
            alt="Cornell Box with Spheres"
            caption="Cornell Box with Spheres"
            width={400}
            height={400}
          />
        </div>
        <hr className="mt-8" />
      </section>

      <section id="bvh" className="mb-8">
        <h2 className="text-2xl font-semibold mb-4">Bounding Volume Hierarchy</h2>
        <p className="text-lg">
          In order to speed up ray tracing, we use a Bounding Volume Hierarchy (BVH). Typically when ray tracing, we have to check every single primative in the scene to see if it intersects with the ray. A BVH is a tree structure where each node contains a bounding box, leaf nodes each contain a subset of the scenes primatives, and internal nodes contain pointers to nodes with smaller bounding boxes of subdivisions of primatives. In order to check for intersection we can check if the ray intersects the root bounding box which is a very efficient operation. If it does not intersect the bounding box then we know it doesn&apos;t intersect any of the children of the current node so we don&apos;t need to continue to compute intersections. If it does intersect the bounding box we can recursively call the intersection test on all nodes that the ray intersects until we have processed each of the primitives or found bounding boxes that the ray doesn&apos;t intersect with.
        </p>
        <p className="text-lg mt-4">
          In order to construct the bvh we first draw a bounding box around all of the primatives. We then compute the mean of the center of each of our primatives and split our primatives into two groups based if the center of the primative falls on the left or the right (for x and y axes) of the mean or above or below the mean (for z axis). Each split divides the space into two bounding boxes. We compute the surface area of each bounding box and choose which of these axes to split on based on the minimum of the maximum of each of the axes&apos; bounding boxes. This ensures that our splits are as even as possible. We recursively apply this split to each of the bounding boxes until we have a BVH with leaf nodes containing less than m primatives.
        </p>
        <p className="text-lg mt-4">
          Below are several images generated with our BVH implementation. To compare the performance of our BVH we rendered the Bunny and Coil scenes with and without the BVH. Without the BVH these renderings took 85 seconds and 23 seconds respectively. With the BVH these renderings took 0.07 seconds and 0.08 seconds. That is over 1,200x faster in the case of the bunny and 250x faster in the case of the coil. The Dragon and Lucy scenes took far too long to render without the BVH, but with the BVH they are rendered in less than a second.
        </p>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-8 mt-8">
          <ImageFigure
            src="/assets/project9/part-2/CBbunny.png"
            alt="Cornell Box with Bunny"
            caption="Cornell Box with Bunny"
            width={400}
            height={400}
          />
          <ImageFigure
            src="/assets/project9/part-2/CBcoil.png"
            alt="Cornell Box with Coil"
            caption="Cornell Box with Coil"
            width={400}
            height={400}
          />
          <ImageFigure
            src="/assets/project9/part-2/CBdragon.png"
            alt="Cornell Box with Dragon"
            caption="Cornell Box with Dragon"
            width={400}
            height={400}
          />
          <ImageFigure
            src="/assets/project9/part-2/CBlucy.png"
            alt="Cornell Box with Lucy"
            caption="Cornell Box with Lucy"
            width={400}
            height={400}
          />
        </div>
        <hr className="mt-8" />
      </section>

      <section id="direct-illumination" className="mb-8">
        <h2 className="text-2xl font-semibold mb-4">Direct Illumination</h2>
        <p className="text-lg">
          With our Bounding Volume Hierarchy we can now turn toward the problem of simulating light transport in the scene. Our camera will only register light which reaches it. We can break up the light reaching the camera into the light coming directly from light sources and the light that bounces off of materials from light sources. In this section we do not consider additional bounces of light from surface to surface, as we will do that in part 4. In order to determine how much light reaches a specific pixel of the camera&apos;s sensor we can either just return the amount of light emitted in the case of zero-bounce light and, for once-bounce light, we can use the reflection equation and sampling / montecarlo integration to estimate the amount of light coming out of this surface along the ray pointing to the camera.
        </p>
        <p className="text-lg mt-4">
          We implemenet two different ways of sampling the irradiance falling on some point in the scene. The first is uniform hemisphere sampling where we sample uniformly from a hemisphere surrounding the point. This sampling method is sufficient for computing and unbiased estimator of the integral of all light falling on this point; however, it is often noisy. In order to get a less noisy result we can implement our second sampling method: importance sampling. In importance sampling we sample a ray from a camera to get an intersection with a point and then for each light in the scene sample several rays which point from the point to some point on the lamp. If the ray doesn&apos;t intersect anything before the light then we know the irradiance that falls on the surface from this light in the scene. This is sufficient for our purposes when we considering only one-bounce light because all radiance in the scene comes from light sources.
        </p>
        <p className="text-lg mt-4">
          Below are some results from uniform hemisphere sampling and importance sampling. We can see that the hemisphere sampled points are much noiser for scenes with less samples. These differences begin to converge with more samples as both are unbiased estimators of the actual integral, but our importance sampled scene appears to converge to the expected output faster due to its nature. Since the sampled rays which dont interect with lights do not add any one-bounce light to the scene, we can get closer to the actual result faster by not sampling these rays and instead only sampling rays which will intersect with lights and add one-bounce light to the scene.
        </p>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-8 mt-8">
          <ImageFigure
            src="/assets/project9/part-3/CBbunny_H_16_8.png"
            alt="Hemisphere Sampled Bunny: 16 Rays Per Pixel"
            caption="Hemisphere Sampled Bunny: 16 Rays Per Pixel"
            width={400}
            height={400}
          />
          <ImageFigure
            src="/assets/project9/part-3/CBbunny_H_64_32.png"
            alt="Hemisphere Sampled Bunny: 64 Rays Per Pixel"
            caption="Hemisphere Sampled Bunny: 64 Rays Per Pixel"
            width={400}
            height={400}
          />
          <ImageFigure
            src="/assets/project9/part-3/CBbunny_16_8.png"
            alt="Importance Sampled Bunny: 16 Rays Per Pixel"
            caption="Importance Sampled Bunny: 16 Rays Per Pixel"
            width={400}
            height={400}
          />
          <ImageFigure
            src="/assets/project9/part-3/CBbunny_64_32.png"
            alt="Importance Sampled Bunny: 64 Rays Per Pixel"
            caption="Importance Sampled Bunny: 64 Rays Per Pixel"
            width={400}
            height={400}
          />
          <ImageFigure
            src="/assets/project9/part-3/CBspheres_H_16_8.png"
            alt="Hemisphere Sampled Spheres: 16 Rays Per Pixel"
            caption="Hemisphere Sampled Spheres: 16 Rays Per Pixel"
            width={400}
            height={400}
          />
          <ImageFigure
            src="/assets/project9/part-3/CBspheres_H_64_32.png"
            alt="Hemisphere Sampled Spheres: 64 Rays Per Pixel"
            caption="Hemisphere Sampled Spheres: 64 Rays Per Pixel"
            width={400}
            height={400}
          />
          <ImageFigure
            src="/assets/project9/part-3/CBspheres_16_8.png"
            alt="Importance Sampled Spheres: 16 Rays Per Pixel"
            caption="Importance Sampled Spheres: 16 Rays Per Pixel"
            width={400}
            height={400}
          />
          <ImageFigure
            src="/assets/project9/part-3/CBspheres_64_32.png"
            alt="Importance Sampled Spheres: 64 Rays Per Pixel"
            caption="Importance Sampled Spheres: 64 Rays Per Pixel"
            width={400}
            height={400}
          />
        </div>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-8 mt-8">
          <ImageFigure
            src="/assets/project9/part-3/CBbunny_1_1.png"
            alt="Bunny: 1 Sample Per Pixel, 1 Light Ray"
            caption="Bunny: 1 Sample Per Pixel, 1 Light Ray"
            width={400}
            height={400}
          />
          <ImageFigure
            src="/assets/project9/part-3/CBbunny_1_4.png"
            alt="Bunny: 1 Sample Per Pixel, 4 Light Rays"
            caption="Bunny: 1 Sample Per Pixel, 4 Light Rays"
            width={400}
            height={400}
          />
          <ImageFigure
            src="/assets/project9/part-3/CBbunny_1_16.png"
            alt="Bunny: 1 Sample Per Pixel, 16 Light Rays"
            caption="Bunny: 1 Sample Per Pixel, 16 Light Rays"
            width={400}
            height={400}
          />
          <ImageFigure
            src="/assets/project9/part-3/CBbunny_1_64.png"
            alt="Bunny: 1 Sample Per Pixel, 64 Light Rays"
            caption="Bunny: 1 Sample Per Pixel, 64 Light Rays"
            width={400}
            height={400}
          />
        </div>
        <hr className="mt-8" />
      </section>

      <section id="global-illumination" className="mb-8">
        <h2 className="text-2xl font-semibold mb-4">Global Illumination</h2>
        <p className="text-lg">
          In our code, we first got a local coordinate frame whose z-axis aligns with the surface normal at the intersection point (0, 0, 1). We transform the outgoing direction (looking back toward the camera) into this local space, where the material&apos;s BSDF can be sampled more easily. If we are accumulating multiple bounces, we add the &quot;one_bounce&quot; direct lighting contribution from the local hit before moving on. We may then either apply Russian Roulette checking to decide whether to end the light path early; if we continue, we sample a new incoming direction from the BSDF in local coordinates and transform it back to world space. Next, we form a new ray slightly offset from the surface to avoid self collisions and trace it through the scene. If that new ray hits another surface and we still have bounces left, we recursively call the same function on that next intersection. The returned radiance from the subsequent bounces is multiplied by the BSDF value, the cosine of the angle between our sampled direction and the local normal, and an additional probability factor to ensure the method stays &quot;unbiased&quot; under Russian Roulette termination checking. Finally, we divide by the probability density from the BSDF sampling and add the result to our indirect lighting estimate for this point to get our L_out return.
        </p>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-8 mt-8">
          <ImageFigure
            src="/assets/project9/part-4/gems.png"
            alt="Gems 1024 Samples Per Pixel"
            caption="Gems 1024 Samples Per Pixel"
            width={400}
            height={400}
          />
          <ImageFigure
            src="/assets/project9/part-4/wall-e.png"
            alt="Wall-E 1024 Samples Per Pixel"
            caption="Wall-E 1024 Samples Per Pixel"
            width={400}
            height={400}
          />
          <ImageFigure
            src="/assets/project9/part-4/building.png"
            alt="Building 1024 Samples Per Pixel"
            caption="Building 1024 Samples Per Pixel"
            width={400}
            height={400}
          />
          <ImageFigure
            src="/assets/project9/part-4/banana.png"
            alt="Banana 1024 Samples Per Pixel"
            caption="Banana 1024 Samples Per Pixel"
            width={400}
            height={400}
          />
          <ImageFigure
            src="/assets/project9/part-4/bunny_direct.png"
            alt="Bunny Only Direct Light"
            caption="Bunny Only Direct Light"
            width={400}
            height={400}
          />
          <ImageFigure
            src="/assets/project9/part-4/bunny_indirect.png"
            alt="Bunny Only Indirect Light"
            caption="Bunny Only Indirect Light"
            width={400}
            height={400}
          />
        </div>
        <p className="text-lg mt-6">
          Below we consider the difference between multiple bounces of light and how they accumulate. The top images show the light only added at that bounce and the bottom row shows the total accumulated light in the image at that step. We can see that before the second step the ceiling is unlit. With the second bounce we add that lighting to the scene. The third bounce adds even more subtlety to the scene by making everything look slightly brighter and more realistic.
        </p>
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mt-8">
          <ImageFigure
            src="/assets/project9/part-4/bunny_bounce0.png"
            alt="Bunny: 0 Bounces"
            caption="Bunny: 0 Bounces"
            width={300}
            height={300}
          />
          <ImageFigure
            src="/assets/project9/part-4/bunny_bounce1.png"
            alt="Bunny: 1 Bounce"
            caption="Bunny: 1 Bounce"
            width={300}
            height={300}
          />
          <ImageFigure
            src="/assets/project9/part-4/bunny_bounce2.png"
            alt="Bunny: 2 Bounces"
            caption="Bunny: 2 Bounces"
            width={300}
            height={300}
          />
          <ImageFigure
            src="/assets/project9/part-4/bunny_bounce3.png"
            alt="Bunny: 3 Bounces"
            caption="Bunny: 3 Bounces"
            width={300}
            height={300}
          />
          <ImageFigure
            src="/assets/project9/part-4/bunny_bounce4.png"
            alt="Bunny: 4 Bounces"
            caption="Bunny: 4 Bounces"
            width={300}
            height={300}
          />
          <ImageFigure
            src="/assets/project9/part-4/bunny_bounce5.png"
            alt="Bunny: 5 Bounces"
            caption="Bunny: 5 Bounces"
            width={300}
            height={300}
          />
        </div>
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mt-8">
          <ImageFigure
            src="/assets/project9/part-4/bunny_bounce0_accum.png"
            alt="Bunny: 0 Bounces (Accumulated)"
            caption="Bunny: 0 Bounces (Accumulated)"
            width={300}
            height={300}
          />
          <ImageFigure
            src="/assets/project9/part-4/bunny_bounce1_accum.png"
            alt="Bunny: 1 Bounce (Accumulated)"
            caption="Bunny: 1 Bounce (Accumulated)"
            width={300}
            height={300}
          />
          <ImageFigure
            src="/assets/project9/part-4/bunny_bounce2_accum.png"
            alt="Bunny: 2 Bounces (Accumulated)"
            caption="Bunny: 2 Bounces (Accumulated)"
            width={300}
            height={300}
          />
          <ImageFigure
            src="/assets/project9/part-4/bunny_bounce3_accum.png"
            alt="Bunny: 3 Bounces (Accumulated)"
            caption="Bunny: 3 Bounces (Accumulated)"
            width={300}
            height={300}
          />
          <ImageFigure
            src="/assets/project9/part-4/bunny_bounce4_accum.png"
            alt="Bunny: 4 Bounces (Accumulated)"
            caption="Bunny: 4 Bounces (Accumulated)"
            width={300}
            height={300}
          />
          <ImageFigure
            src="/assets/project9/part-4/bunny_bounce5_accum.png"
            alt="Bunny: 5 Bounces (Accumulated)"
            caption="Bunny: 5 Bounces (Accumulated)"
            width={300}
            height={300}
          />
        </div>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-8 mt-8">
          <ImageFigure
            src="/assets/project9/part-4/dragon_1_4.png"
            alt="Dragon: 1 Sample Per Pixel"
            caption="Dragon: 1 Sample Per Pixel"
            width={400}
            height={400}
          />
          <ImageFigure
            src="/assets/project9/part-4/dragon_2_4.png"
            alt="Dragon: 2 Samples Per Pixel"
            caption="Dragon: 2 Samples Per Pixel"
            width={400}
            height={400}
          />
          <ImageFigure
            src="/assets/project9/part-4/dragon_4_4.png"
            alt="Dragon: 4 Samples Per Pixel"
            caption="Dragon: 4 Samples Per Pixel"
            width={400}
            height={400}
          />
          <ImageFigure
            src="/assets/project9/part-4/dragon_8_4.png"
            alt="Dragon: 8 Samples Per Pixel"
            caption="Dragon: 8 Samples Per Pixel"
            width={400}
            height={400}
          />
          <ImageFigure
            src="/assets/project9/part-4/dragon_16_4.png"
            alt="Dragon: 16 Samples Per Pixel"
            caption="Dragon: 16 Samples Per Pixel"
            width={400}
            height={400}
          />
          <ImageFigure
            src="/assets/project9/part-4/dragon_64_4.png"
            alt="Dragon: 64 Samples Per Pixel"
            caption="Dragon: 64 Samples Per Pixel"
            width={400}
            height={400}
          />
        </div>
        <div className="flex justify-center mt-6">
          <ImageFigure
            src="/assets/project9/part-4/dragon_1024_4.png"
            alt="Dragon: 1024 Samples Per Pixel"
            caption="Dragon: 1024 Samples Per Pixel"
            width={400}
            height={400}
          />
        </div>
        <hr className="mt-8" />
      </section>

      <section id="adaptive-sampling" className="mb-8">
        <h2 className="text-2xl font-semibold mb-4">Adaptive Sampling</h2>
        <p className="text-lg">
          Adaptive sampling lets the renderer decide, on a per‐pixel basis of sorts, when it has accumulated enough samples to produce a stable result without wasting extra computation. In other words, it measures the current estimate&apos;s variability and stops sampling early if the pixel&apos;s color is already sufficiently converged to its rendered color. For each pixel, our code begins taking samples, which are just rays, and accumulating the resulting color. It also keeps track of the luminance of each sample in two running sums s1 and s2. Every samplesPerBatch samples, we calculate the current sample mean and variance from the running sums we calculated earlier. A 95% confidence‐interval I is then computed to determine whether or not we deem the pixel has converged or not. We keep going if the pixel hasn&apos;t converged yet.
        </p>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-8 mt-8">
          <ImageFigure
            src="/assets/project9/part-5/bunny.png"
            alt="Bunny Scene Rendered With Adaptive Sampling"
            caption="Bunny Scene Rendered With Adaptive Sampling"
            width={400}
            height={400}
          />
          <ImageFigure
            src="/assets/project9/part-5/bunny_rate.png"
            alt="Bunny Scene Sampling Rate"
            caption="Bunny Scene Sampling Rate"
            width={400}
            height={400}
          />
          <ImageFigure
            src="/assets/project9/part-5/spherical.png"
            alt="Spheres Scene Rendered With Adaptive Sampling"
            caption="Spheres Scene Rendered With Adaptive Sampling"
            width={400}
            height={400}
          />
          <ImageFigure
            src="/assets/project9/part-5/spherical_rate.png"
            alt="Spheres Scene Sampling Rate"
            caption="Spheres Scene Sampling Rate"
            width={400}
            height={400}
          />
        </div>
      </section>
    </div>
  );
};

export default ProjectPage; 